{"meta":{"title":"深秋","subtitle":"","description":"lateautumn","author":"深秋","url":"https://lateautumn.cn","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"08-28","excerpt":""},{"title":"about","text":"这个人很懒,暂时没有自我介绍哦!(…….)","path":"about/index.html","date":"08-28","excerpt":""},{"title":"歌单","text":"我喜欢的音乐 毛不易 见我岂不如见青山 周杰伦 人间忽晚,山河已秋 电音 当时只道是平常 十年故梦远 检查这个页面是否失效 http://music.163.com/playlist?id=704153154&amp;userid=471545869 http://music.163.com/playlist?id=5098386411&amp;userid=471545869 http://music.163.com/playlist?id=6959082669&amp;userid=471545869 http://music.163.com/playlist?id=6830242117&amp;userid=471545869 http://music.163.com/playlist?id=6800404160&amp;userid=471545869 http://music.163.com/playlist?id=6798364648&amp;userid=471545869 http://music.163.com/playlist?id=734751409&amp;userid=471545869 http://music.163.com/playlist?id=708368182&amp;userid=471545869 http://music.163.com/playlist?id=704116994&amp;userid=471545869","path":"playlist/index.html","date":"08-30","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"08-28","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"09-23","excerpt":""}],"posts":[{"title":"2021的总结","text":"我的2021年终总结其实仔细想想,今年其实也没做什么事,一直都在疯狂学习,疯狂学习中度过吧,今年离了一次职,也入职了一家新公司,也对今年有了一个交代吧,其实也不知道该总结一些什么,就姑且说一些琐事吧. 过去,曾经大学在长沙,工作也在长沙,大二暑假,老师给推荐去的,记得当时去了好一批人吧,不过后续也没几人留下来吧,我也算是最后走的那一批人了吧。不过这段工作经验也确实提升了我不少,毕竟以前的我,用现在的网络用语来说,就是一个老社恐了吧,那段时间的与各种人交流,时不时的开会演讲,真的让我这个社恐稍微能有那么一点点不社恐了,外出时,也与司机师傅混的风生水起。 说到离职的原因,还是又累又忙,工资又少吧,老板天天画大饼,活卖力的干,结果却没有应该得到的,也许就是实习生好压榨吧,一年又一年,想起当初一起进公司的室友,有一个算是最早看开的吧,干了一个月,觉得不适合自己,回家发展去了,现在做一个制图,时不时还能带几个新员工,去年最累的那段日子,是真的羡慕他,不过今年由于我自己的原因也有很久没联系他了,不知道他现在干的咋样;还有一个,走的要比我晚一个月,现在偶尔还是有联系,上次联系的时候,吃了一顿饭,他现在在做销售,之前烟酒不沾,现在不得不向生活低了头,只能说生活不易,都在负重前行,剩下的一个室友,就一起来了广州,曾经,也就这样吧。 未来，现在现在在广州，未来应该也还是在广州吧，希望这两年能好好的沉淀自己，（啊这，实在是不知道该说什么了，要不明天补上）","path":"2022/01/01/2021的总结/","date":"01-01","excerpt":"","tags":[{"name":"总结","slug":"总结","permalink":"https://lateautumn.cn/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"webpack打包优化","text":"vue项目的打包上线及优化 项目完成,将项目进行上线时,为了提升性能,会进行一些优化处理 项目的常见优化 项目打包之后，会将之前所使用到的部署依赖包和项目中使用到的外部资源都打包 如果之前引入的包很多，或者引入的不必需的包，那么会增大项目的体积，从而造成用户访问的时候需要请求更多的数据才能正常的访问，不利于用户体验，所以需要对打包过程进行优化 一般情况下我们可以从优化代码的方面对项目进行优化，也可以使用类似cdn的方式对项目进行优化 脚手架中提供了一个命令，可以让我们看到项目的资源的分布(占用)情况：npm run build – –report 121.报告页面中，越大的块说明这个模板占用的体积越大2.占用体积越越大的模块，我们要考虑不将其打包到产品中 cdn加速优化 cdn: CDN的本质上是将媒体资源，动静态图片（Flash），HTML，CSS，JS等等内容缓存到距离你更近的IDC，从而让用户进行共享资源，实现缩减站点间的响应时间等等需求，而网游加速器的本质则是通过建立高带宽机房，架设多节点服务器来为用户进行加速。 我们可以将一些大体积的模块，让cdn帮我们提供相应的资源，这样就可以缓解我们自己的服务器的压力，同时提供更快更好的资源响应 vue.config.js 在脚手架项目中，如果想增加自己的项目配置，可以在根目录下添加vue.config.js文件，在这个文件中实现自定义的配置 在打包的时候，这个配置会和脚手架的配置组合到一起 添加包的排除123456789module.exports = &#123; configureWebpack: &#123; externals:&#123; &#x27;vue&#x27;: &#x27;Vue&#x27;, &#x27;element-ui&#x27;: &#x27;ELEMENT&#x27;, &#x27;quill&#x27;: &#x27;Quill&#x27; &#125; &#125;,&#125; 通过对比可以发现,打包后的体积显著性的减少,但是此时,问题并未解决,由于缺失了必要的包,所有项目会无法运行,所有我们需要采用cdn的方式引入在线地址 添加cdn12345678910111213141516let cdn = &#123; css: [ // element-ui css &#x27;https://unpkg.com/element-ui/lib/theme-chalk/index.css&#x27;,// 样式表 // 富文本框插件样式 &#x27;https://cdn.bootcdn.net/ajax/libs/quill/2.0.0-dev.4/quill.bubble.css&#x27; ], js: [ // vue must at first! &#x27;https://unpkg.com/vue/dist/vue.js&#x27;, // vuejs // element-ui js &#x27;https://unpkg.com/element-ui/lib/index.js&#x27;, // elementUI // 富文本框插件 &#x27;https://cdn.bootcdn.net/ajax/libs/quill/2.0.0-dev.4/quill.js&#x27; ]&#125; 通过插件将资源自动的添加到页面中挂载资源到插件12345678910111213module.exports = &#123; // 添加打包排除，说明以下配置中的包将来不会打包到项目中 configureWebpack: &#123; externals &#125;, // 将cdn的资源挂载到插件上 chainWebpack (config) &#123; config.plugin(&#x27;html&#x27;).tap(args =&gt; &#123; args[0].cdn = cdn return args &#125;) &#125;&#125; 在页面中使用插件添加指定的cdn资源 添加css引入(head结构中） 123&lt;% for(var css of htmlWebpackPlugin.options.cdn.css) &#123; %&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;&lt;%=css%&gt;&quot; /&gt;&lt;% &#125; %&gt; 添加js引入(body结构中) 123&lt;% for(var js of htmlWebpackPlugin.options.cdn.js) &#123; %&gt; &lt;script src=&quot;&lt;%=js%&gt;&quot;&gt;&lt;/script&gt;&lt;% &#125; %&gt; 重新打包，OK 设置只有产品阶段才使用cdn 在项目开发的时候，其实没有必要使用cdn,这样反而会让我们的页面加载效率下降，同时也不适合本地开发(需要连网) 我们可以根据环境变量进行相应的处理，只有在产品的时候，才让插件去自动注入相应的资源文件到html页面 1234567891011121314151617181920212223242526272829303132333435363738394041424344const isProd = process.env.NODE_ENV === &#x27;production&#x27; // 是否生产环境let externals = &#123; &#x27;vue&#x27;: &#x27;Vue&#x27;, &#x27;element-ui&#x27;: &#x27;ELEMENT&#x27;, &#x27;quill&#x27;: &#x27;Quill&#x27;&#125;let cdn = &#123; css: [ // element-ui css &#x27;https://unpkg.com/element-ui/lib/theme-chalk/index.css&#x27;,// 样式表 // 富文本框插件样式 &#x27;https://cdn.bootcdn.net/ajax/libs/quill/2.0.0-dev.4/quill.bubble.css&#x27; ], js: [ // vue must at first! &#x27;https://unpkg.com/vue/dist/vue.js&#x27;, // vuejs // element-ui js &#x27;https://unpkg.com/element-ui/lib/index.js&#x27;, // elementUI // 富文本框插件 &#x27;https://cdn.bootcdn.net/ajax/libs/quill/2.0.0-dev.4/quill.js&#x27; ]&#125;cdn = isProd ? cdn : &#123; css: [], js: [] &#125;externals = isProd ? externals : &#123;&#125;module.exports = &#123; // 添加打包排除，说明以下配置中的包将来不会打包到项目中 configureWebpack: &#123; externals &#125;, // chainWebpack (config) &#123; config.plugin(&#x27;html&#x27;).tap(args =&gt; &#123; args[0].cdn = cdn return args &#125;) &#125;&#125;","path":"2021/09/23/webpack打包优化/","date":"09-23","excerpt":"","tags":[{"name":"webapck","slug":"webapck","permalink":"https://lateautumn.cn/tags/webapck/"}]},{"title":"vue组件","text":"组件化:封装的思想,把页面上可重用的部分,封装为组件,从而方便项目的开发和维护一个页面,可以拆分成一个个组件,一个组件就是一个整体,每个组件都可以有自己独立的结构样式和行为 组件通信每个组件的变量和值都是独立的,在进行值传递时,则需要用到组件通信 1.父传子 示例 创建一个父文件,father.vue 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div&gt; &lt;!-- 目标: 父(App.vue) -&gt; 子(MyProduct.vue) 分别传值进入 需求: 每次组件显示不同的数据信息 步骤(口诀): 1. 子组件 - props - 变量 (准备接收) 2. 父组件 - 传值进去 --&gt; &lt;Product title=&quot;好吃的口水鸡&quot; price=&quot;50&quot; intro=&quot;开业大酬宾, 全场8折&quot;&gt;&lt;/Product&gt; &lt;Product title=&quot;好可爱的可爱多&quot; price=&quot;20&quot; intro=&quot;老板不在家, 全场1折&quot;&gt;&lt;/Product&gt; &lt;Product title=&quot;好贵的北京烤鸭&quot; price=&quot;290&quot; :intro=&quot;str&quot;&gt;&lt;/Product&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 1. 引入子组件import Product from &#x27;./components/MyProduct&#x27;export default &#123; data()&#123; return &#123; str: &quot;好贵啊, 快来啊, 好吃&quot; &#125; &#125;, // 3. 注册组件 components: &#123; // Product: Product // key和value变量名同名 - 简写 Product &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 创建一个字文件MyProduct 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;h3&gt;标题: &#123;&#123; title &#125;&#125;&lt;/h3&gt; &lt;p&gt;价格: &#123;&#123; price &#125;&#125;元&lt;/p&gt; &lt;p&gt;&#123;&#123; intro &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; //通过props属性定义接收的key props: [&#x27;title&#x27;, &#x27;price&#x27;, &#x27;intro&#x27;]&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 单向数据流 从父组件传至子组件的数据,不能被子组件所修改,遵循单向数据流的原则,子组件只有只读的属性 2.子传父 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div class=&quot;my-product&quot;&gt; &lt;h3&gt;标题: &#123;&#123; title &#125;&#125;&lt;/h3&gt; &lt;p&gt;价格: &#123;&#123; price &#125;&#125;元&lt;/p&gt; &lt;p&gt;&#123;&#123; intro &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;subFn&quot;&gt;宝刀-砍1元&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import eventBus from &#x27;../EventBus&#x27;export default &#123; props: [&#x27;index&#x27;, &#x27;title&#x27;, &#x27;price&#x27;, &#x27;intro&#x27;], methods: &#123; subFn()&#123; //在子组件中通过this.$emit方法传值给父组件 //第一个为父组件接收时使用的方法名,第二个为需要传递的值 this.$emit(&#x27;subprice&#x27;, this.index, 1) // 子向父 eventBus.$emit(&quot;send&quot;, this.index, 1) // 跨组件 &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 接收 1234567891011121314151617181920212223242526272829303132333435363738template&gt; &lt;div&gt; &lt;!-- 目标: 子传父 --&gt; &lt;!-- 1. 父组件, @自定义事件名=&quot;父methods函数&quot; --&gt; &lt;MyProduct v-for=&quot;(obj, ind) in list&quot; :key=&quot;obj.id&quot; :title=&quot;obj.proname&quot; :price=&quot;obj.proprice&quot; :intro=&quot;obj.info&quot; :index=&quot;ind&quot; @subprice=&quot;fn&quot; //key为子组件设置的方法名,value为函数名 &gt;&lt;/MyProduct&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import MyProduct from &#x27;./components/MyProduct_sub&#x27;export default &#123; data() &#123; return &#123; .......... &#125;; &#125;, components: &#123; MyProduct &#125;, methods: &#123; //形参接收传过来的实参 fn(inde, price)&#123; // 逻辑代码 this.list[inde].proprice &gt; 1 &amp;&amp; (this.list[inde].proprice = (this.list[inde].proprice - price).toFixed(2)) &#125; &#125;&#125;;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 3.子与子互传 目标: 常用于跨组件通信时使用 创建空白vue对象EventBus.vue-监听事件 123import Vue from &#x27;vue&#x27;//导出空白对象export default new Vue() 组件1传值 123456789101112131415161718192021222324&lt;template&gt; &lt;div class=&quot;my-product&quot;&gt; &lt;h3&gt;标题: &#123;&#123; title &#125;&#125;&lt;/h3&gt; &lt;p&gt;价格: &#123;&#123; price &#125;&#125;元&lt;/p&gt; &lt;p&gt;&#123;&#123; intro &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;subFn&quot;&gt;宝刀-砍1元&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; //导入空白vue对象,监听事件import eventBus from &#x27;../EventBus&#x27;export default &#123; props: [&#x27;index&#x27;, &#x27;title&#x27;, &#x27;price&#x27;, &#x27;intro&#x27;], methods: &#123; subFn()&#123; this.$emit(&#x27;subprice&#x27;, this.index, 1) &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 组件2接收 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;ul class=&quot;my-product&quot;&gt; &lt;li v-for=&quot;(item, index) in arr&quot; :key=&quot;index&quot;&gt; &lt;span&gt;&#123;&#123; item.proname &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; item.proprice &#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;// 目标: 跨组件传值// 1. 引入空白vue对象(EventBus)// 2. 接收方 - $on监听事件import eventBus from &quot;../EventBus&quot;;export default &#123; props: [&quot;arr&quot;], // 3. 组件创建完毕, 监听send事件 created() &#123; //使用eventBus.$on接收传值 eventBus.$on(&quot;send&quot;, (index, price) =&gt; &#123; console.log(index,price) &#125;); &#125;,&#125;;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 生命周期 组件从创建到销毁的整个过程就是生命周期 _钩子函数 目标: Vue 框架内置函数，随着组件的生命周期阶段，自动执行 作用: 特定的时间点，执行特定的操作 场景: 组件创建完毕后，可以在created 生命周期函数中发起Ajax 请求，从而初始化 data 数据 分类: 4大阶段8个方法 初始化 挂载 更新 销毁 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;template&gt;&lt;!-- vue生命周期 --&gt; &lt;div&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;button @click=&quot;complte&quot;&gt;数据更新&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;data () &#123; return &#123; msg:&#x27;hello,vue&#x27; &#125;&#125;,methods: &#123; complte()&#123; this.msg = &#x27;hello.world&#x27; this.$destroy() &#125;&#125;,//初始化函数及事件beforeCreate () &#123; console.log(&#x27;初始化函数及事件,无法打印出数据&#x27;,this.msg)&#125;,//初始化数据created () &#123; console.log(&#x27;初始化数据,可以打印出数据&#x27;,this.msg)&#125;,//挂载前事件beforeMount () &#123; console.log(&#x27;虚拟dom挂载成真实dom前,无法打印出dom元素&#x27;,document.querySelector(&#x27;h1&#x27;))&#125;,//挂载后事件mounted () &#123; console.log(&#x27;虚拟dom挂载成真实dom,可以打印出dom元素&#x27;,document.querySelector(&#x27;h1&#x27;))&#125;,//dom数据更新前事件beforeUpdate () &#123; console.log(&#x27;打印出数据更新之前的dom元素&#x27;,document.querySelector(&#x27;h1&#x27;))&#125;,updated () &#123; console.log(&#x27;打印出数据更新之后的dom元素&#x27;,document.querySelector(&#x27;h1&#x27;))&#125;,//实例销毁前事件beforeDestroy () &#123; console.log(&#x27;移除所有组件&#x27;)&#125;,//实例销毁后事件destroyed () &#123; console.log(&#x27;实例销毁后事件,更新事件无法打印&#x27;)&#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; ​​","path":"2021/09/04/api/","date":"09-04","excerpt":"组件化:封装的思想,把页面上可重用的部分,封装为组件,从而方便项目的开发和维护一个页面,可以拆分成一个个组件,一个组件就是一个整体,每个组件都可以有自己独立的结构样式和行为","tags":[{"name":"vue","slug":"vue","permalink":"https://lateautumn.cn/tags/vue/"}]},{"title":"杂记","text":"去年今日此门中人面桃花相印红人面不知何处去桃花依旧笑春风 关于本博客框架本主题框架来自 [AONOSORA] 大佬的移植,(膜拜),可惜与此主题相见恨晚,毕竟也是看着弟弟的网站一路走来,只是右键欧尼酱虽有,但还是缺少了刮一刮的透视功能,略感可惜,看大佬关于此框架的github更新已是两年前,估计添加无望了. ….END 关于音乐插件首先音乐插件来源于DiyGod大佬的开源项目,地址–&gt;Aplayer,关注大佬的博客很久了,也对大佬今年的选择感到惋惜,不过愿大佬此去能有表述那样的发展 ……END 本次修改删除了原本的随机文章功能,新增了音乐插件功能 新增了歌单播放pag 能力有限,暂时无法通过传参达到在配置文件中切换歌曲信息,待实现 ……END 修改添加了随机诗词功能,使用天行api的接口 ……END 09-18 预期前段时间看清风的扫书推荐,突然就萌生了想搬运过来的想法,主要是记录一下,顺便给自己做个书单记录一下往昔看过的小说,试着问了一下清风,得到了肯定回答,等个机会吧,搬一下清风的扫书文章 (清风=&gt;清风霁月笑红尘) ……END 09.23","path":"2021/08/30/musiccase/","date":"08-30","excerpt":"去年今日此门中人面桃花相印红人面不知何处去桃花依旧笑春风","tags":[{"name":"Aplayer","slug":"Aplayer","permalink":"https://lateautumn.cn/tags/Aplayer/"},{"name":"edit","slug":"edit","permalink":"https://lateautumn.cn/tags/edit/"}]},{"title":"vue","text":"vue是一个渐进式javascript框架,更快的处理速度,更省时间的代码工程 MVVM的设计模式,通过数据驱动视图改变,通过vue内部源码操作Dom元素,达到不操作Dom,只改变数据,来达到页面变化 —-08.29 am vue环境配置 工程化开发方式(webpack环境下) @vue/cli是vue官方提供的一个全局模块包 vue create vuecli-demo 创建一个vue项目 1234//定位至创建的文件夹cd vuecli-demo//开启项目服务器npm run serve @vue/cli 脚手架目录1234567891011121314151617vuecil-demo # 项目目录 ├── node_modules # 项目依赖的第三方包 ├── public # 静态文件目录 ├── favicon.ico# 浏览器小图标 └── index.html # 单页面的html文件(网页浏览的是它) ├── src # 业务文件夹 ├── assets # 静态资源 └── logo.png # vue的logo图片 ├── components # 组件目录 └── HelloWorld.vue # 欢迎页面vue代码文件 ├── App.vue # 整个应用的根组件 └── main.js # 入口js文件 ├── .gitignore # git提交忽略配置 ├── babel.config.js # babel配置 ├── package.json # 依赖包列表 ├── README.md # 项目说明└── yarn.lock # 项目包版本锁定和缓存地址 主要文件及功能12345node_modules //下载的第三方包public/index.html //浏览器运行的网页src/main.js //webpack打包的入口文件src/App.vue //vue项目入口页面package.json //依赖包列表文件 若要在脚手架中配置自定义配置,则需在src同级目录下添加vue.config.js文件,基础配置如下; 1234567module.exports = &#123;lintOnSave:false, //关闭代码检查工具=&gt;eslint组件devServer:&#123; open: true, //设置自动打开浏览器 port:3000 //设置默认打开端口号&#125;&#125; vue基础语法12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; //template文件中只能有一个根文件 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;data () &#123; return &#123; //默认方法,用于定义template中使用的变量 &#125;&#125;,method:&#123; //用于定义template中使用的函数 &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; vue基础指令 v-bind 语法:v-bind:属性名=&quot;vue变量&quot; 简写: :属性名=&quot;变量名&quot; 将原生元素属性转化成vue属性,得以使用vue方法 123456789101112131415161718&lt;template&gt;&lt;div&gt; &lt;a v-bind:url=&#x27;vue&#x27;&gt;hello,vue-&gt;这是基础写法&lt;/a&gt; &lt;a :url=&#x27;vue&#x27;&gt;hello,vue-&gt;这是省略写法&lt;/a&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;data()&#123; return&#123; vue:&#x27;https://cn.vuejs.org/&#x27; &#125;&#125;&#125;&lt;/script&gt;&lt;/style&gt;&lt;style&gt; v-on 语法 v-on:事件名=”要执行的==少量代码==” v-on:事件名=”methods中的函数” v-on:事件名=”methods中的函数(实参)” 简写 @事件名=”methods中的函数” 12345678910111213141516171819202122232425262728&lt;p&gt;你要买商品的数量: &#123;&#123;count&#125;&#125;&lt;/p&gt;&lt;button v-on:click=&quot;count = count + 1&quot;&gt;增加1&lt;/button&gt;&lt;button @click=&quot;addFn&quot;&gt;增加1个&lt;/button&gt;&lt;button @click=&quot;addCountFn(5)&quot;&gt;一次加5件&lt;/button&gt; &lt;a @click=&quot;one&quot; href=&quot;http://www.baidu.com&quot;&gt;阻止百度&lt;/a&gt; &lt;a @click=&quot;two(10, $event)&quot; href=&quot;http://www.baidu.com&quot;&gt;阻止去百度&lt;/a&gt;&lt;script&gt; export default &#123; // ...其他省略 methods: &#123; addFn()&#123; // this代表export default后面的组件对象(下属有data里return出来的属性) this.count++ &#125;, addCountFn(num)&#123; this.count += num &#125;, subFn()&#123; this.count-- &#125; one(e)&#123; e.preventDefault() //这是事件对象的两种使用方法 &#125;, two(num, e)&#123; e.preventDefault() //这是事件对象的两种使用方法 &#125; &#125; &#125;&lt;/script&gt; v-on修饰符 语法: @事件名.修饰符=”methods里函数” .stop - 阻止事件冒泡 .prevent - 阻止默认行为 .once - 程序运行期间, 只触发一次事件处理函数 123456789101112131415161718192021&lt;template&gt; &lt;div @click=&quot;fatherFn&quot;&gt; &lt;!-- vue对事件进行了修饰符设置, 在事件后面.修饰符名即可使用更多的功能,支持链式编程--&gt; &lt;button @click.stop=&quot;btn&quot;&gt;.stop阻止事件冒泡&lt;/button&gt; &lt;a href=&quot;http://www.baidu.com&quot; @click.prevent=&quot;btn&quot;&gt;.prevent阻止默认行为&lt;/a&gt; &lt;button @click.once=&quot;btn&quot;&gt;.once程序运行期间, 只触发一次事件处理函数&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; fatherFn()&#123; console.log(&quot;father被触发&quot;); &#125;, btn()&#123; console.log(1); &#125; &#125;&#125;&lt;/script&gt; v-on按键修饰符 语法: @keyup.enter - 监测回车按键 @keyup.esc - 监测返回按键 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;input type=&quot;text&quot; @keydown.enter=&quot;enterFn&quot;&gt; &lt;hr&gt; &lt;input type=&quot;text&quot; @keydown.esc=&quot;escFn&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; enterFn()&#123; console.log(&quot;enter回车按键了&quot;); &#125;, escFn()&#123; console.log(&quot;esc按键了&quot;); &#125; &#125;&#125;&lt;/script&gt; v-model 语法: v-model=”vue数据变量” 双向数据绑定 数据变化 -&gt; 视图自动同步 视图变化 -&gt; 数据自动同步 .number 以parseFloat转成数字类型 .trim 去除首尾空白字符 .lazy 在change时触发而非inupt时 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;template&gt; &lt;div&gt; &lt;!-- v-model:是实现vuejs变量和表单标签value属性, 双向绑定的指令 --&gt; &lt;div&gt; &lt;span&gt;用户名:&lt;/span&gt; &lt;input type=&quot;text&quot; v-model.trim=&quot;username&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;密码:&lt;/span&gt; &lt;input type=&quot;password&quot; v-model=&quot;pass&quot; /&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;年龄:&lt;/span&gt; &lt;input type=&quot;text&quot; v-model.number=&quot;age&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;span&gt;来自于: &lt;/span&gt; &lt;!-- 下拉菜单要绑定在select上 --&gt; &lt;select v-model=&quot;from&quot;&gt; &lt;option value=&quot;北京市&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;南京市&quot;&gt;南京&lt;/option&gt; &lt;option value=&quot;天津市&quot;&gt;天津&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div&gt; &lt;!-- (重要) 遇到复选框, v-model的变量值 非数组 - 关联的是复选框的checked属性 数组 - 关联的是复选框的value属性 --&gt; &lt;span&gt;爱好: &lt;/span&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;抽烟&quot;&gt;抽烟 &lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;喝酒&quot;&gt;喝酒 &lt;input type=&quot;checkbox&quot; v-model=&quot;hobby&quot; value=&quot;写代码&quot;&gt;写代码 &lt;/div&gt; &lt;div&gt; &lt;span&gt;性别: &lt;/span&gt; &lt;input type=&quot;radio&quot; value=&quot;男&quot; name=&quot;sex&quot; v-model=&quot;gender&quot;&gt;男 &lt;input type=&quot;radio&quot; value=&quot;女&quot; name=&quot;sex&quot; v-model=&quot;gender&quot;&gt;女 &lt;/div&gt; &lt;div&gt; &lt;span&gt;自我介绍&lt;/span&gt; &lt;textarea v-model.lazy=&quot;intro&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; username: &quot;&quot;, pass: &quot;&quot;, from: &quot;&quot;, hobby: [], sex: &quot;&quot;, intro: &quot;&quot;, &#125;; // 总结: // 特别注意: v-model, 在input[checkbox]的多选框状态 // 变量为非数组, 则绑定的是checked的属性(true/false) - 常用于: 单个绑定使用 // 变量为数组, 则绑定的是他们的value属性里的值 - 常用于: 收集勾选了哪些值 &#125;&#125;;&lt;/script&gt; v-text和v-html 语法: v-text=”vue数据变量” v-html=”vue数据变量” 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;p v-text=&quot;str&quot;&gt;&lt;/p&gt; &lt;p v-html=&quot;str&quot;&gt;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; str: &quot;&lt;span&gt;我是一个span标签&lt;/span&gt;&quot; &#125; &#125;&#125;&lt;/script&gt; v-show和v-if 语法: v-show=”vue变量” v-if=”vue变量” 原理 v-show 用的display:none隐藏 (频繁切换使用) v-if 直接从DOM树上移除 高级 v-else使用 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;h1 v-show=&quot;isOk&quot;&gt;v-show的盒子&lt;/h1&gt; &lt;h1 v-if=&quot;isOk&quot;&gt;v-if的盒子&lt;/h1&gt; &lt;div&gt; &lt;p v-if=&quot;age &gt; 18&quot;&gt;我成年了&lt;/p&gt; &lt;p v-else&gt;还得多吃饭&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; isOk: true, age: 15 &#125; &#125;&#125;&lt;/script&gt; v-for 语法 v-for=”(值, 索引) in 目标结构” v-for=”值 in 目标结构” 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- v-for 把一组数据, 渲染成一组DOM --&gt; &lt;!-- 口诀: 让谁循环生成, v-for就写谁身上 --&gt; &lt;!-- v-for的临时变量名不能用到v-for范围外 --&gt; &lt;p&gt;学生姓名&lt;/p&gt; &lt;ul&gt; &lt;li v-for=&quot;(item, index) in arr&quot; :key=&quot;item&quot;&gt; &#123;&#123; index &#125;&#125; - &#123;&#123; item &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;学生详细信息&lt;/p&gt; &lt;ul&gt; &lt;li v-for=&quot;obj in stuArr&quot; :key=&quot;obj.id&quot;&gt; &lt;span&gt;&#123;&#123; obj.name &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; obj.sex &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; obj.hobby &#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- v-for遍历对象(了解) --&gt; &lt;p&gt;老师信息&lt;/p&gt; &lt;div v-for=&quot;(value, key) in tObj&quot; :key=&quot;value&quot;&gt; &#123;&#123; key &#125;&#125; -- &#123;&#123; value &#125;&#125; &lt;/div&gt; &lt;!-- v-for遍历整数(了解) - 从1开始 --&gt; &lt;p&gt;序号&lt;/p&gt; &lt;div v-for=&quot;i in count&quot; :key=&quot;i&quot;&gt;&#123;&#123; i &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; arr: [&quot;小明&quot;, &quot;小欢欢&quot;, &quot;大黄&quot;], stuArr: [ &#123; id: 1001, name: &quot;孙悟空&quot;, sex: &quot;男&quot;, hobby: &quot;吃桃子&quot;, &#125;, &#123; id: 1002, name: &quot;猪八戒&quot;, sex: &quot;男&quot;, hobby: &quot;背媳妇&quot;, &#125;, ], tObj: &#123; name: &quot;小黑&quot;, age: 18, class: &quot;1期&quot;, &#125;, count: 10, &#125;; &#125;,&#125;;&lt;/script&gt;","path":"2021/08/29/vue/","date":"08-29","excerpt":"vue是一个渐进式javascript框架,更快的处理速度,更省时间的代码工程 MVVM的设计模式,通过数据驱动视图改变,通过vue内部源码操作Dom元素,达到不操作Dom,只改变数据,来达到页面变化 —-08.29 am","tags":[{"name":"vue","slug":"vue","permalink":"https://lateautumn.cn/tags/vue/"}]},{"title":"node","text":"node应该算是全栈的敲门砖吧,在往全栈的大路上又前进了一步…….. 复习下基础语法吧,写了忘,忘了写,总会记住的…. node node是js在服务器端的运行环境 node不能调用浏览器的Dom,Bom元素 node可以导入核心模块,自定义模块,第三方模块 12345678910#导入方法const fs = require(&#x27;fs&#x27;)#导入自定义模块const calc = require(&#x27;./calc.js&#x27;)#需在被导入的模块中添加暴露方法modules.exprots = &#123; calc &#125;#导入第三方模块 const express = require(&#x27;express&#x27;) npm12345678910#npm环境配置 (文件夹名称不能是中文或者特殊字符)npm init --yes#npm环境配置 (文件夹名称不限制,可手动更改)npm init #下载第三方包npm install dayjs //本地路径下载npm install -g nrm //全局下载 expressexpress是一个简洁,灵活的node.js的web应用开发框架,本身由一个路由和无数个中间件组成 123456789101112131415#开启一个服务器的三条代码const express = require(&#x27;express&#x27;)const server = express()server.listen(8001,()=&gt;&#123;&#125;)#路由server.get(&#x27;/login&#x27;,(req,res)=&gt;&#123; res.send(&#x27;这是登录页面&#x27;) //express集成了请求头,会自动识别&#125;)#中间件使用方法const isok = function(req,res,next)&#123; //前端发起请求到后端时,后端指向中间件,由中间件先对请求进行处理,处理完成后,若有其他的中间件,则会指向下一个,没有则指向后端处理 next()&#125; 托管 在express中,内置了一个托管静态页面的功能,如下; 1234567891011#导包const express = require(&#x27;express&#x27;)const server = express()#开启托管server.use(&#x27;/&#x27;, express.static(&#x27;文件夹名&#x27;)) //前缀可选填,托管文件夹必须要与当前文件同级#监听server.listen(8001,()=&gt;&#123; console.log(&#x27;端口已开启&#x27;) &#125;) 由于项目开发过程中,接口也会配置的越来越多,所以传统的路由写法无法满足代码的优化,整洁,所以采用express所提供的路由中间件,将路由配置与路由调用分开 路由配置 1234567891011121314#导包const express = require(&#x27;express&#x27;)//这个就是自带的路由方法const Router = express.Router()//之后所有的配置就在router上Router.get(&#x27;/login&#x27;,(req,res)=&gt;&#123; res.send(&#x27;这是登录页面&#x27;)&#125;)Router.post(&#x27;/index&#x27;,(req,res)=&gt;&#123; res.send(&#x27;这是首页&#x27;)&#125;)#暴露路由函数module.exports = Router 路由调用 123456789101112#导包const express = require(&#x27;express&#x27;)const Router = require(&#x27;./路由配置文件名&#x27;)const server =express()#调用server.use(&#x27;/&#x27;,Router) //指定前缀,可填#监听server.listen(8001,()=&gt;&#123; console.log(&#x27;端口已开启&#x27;) &#125;) CORS开发中由于前后端分离,数据获取并非同源,所以跨域问题非常常见 而在express框架中,跨域的解决过于冗长,灵活性也不太够,所以借用cors包来解决跨域问题是极为方便的方式 1234567#导包const express = require(&#x27;express&#x27;)const cors = require(&#x27;cors&#x27;)const server = express()#开启跨域server.use(cors())","path":"2021/08/20/node/","date":"08-20","excerpt":"node应该算是全栈的敲门砖吧,在往全栈的大路上又前进了一步…….. 复习下基础语法吧,写了忘,忘了写,总会记住的….","tags":[{"name":"node.js","slug":"node-js","permalink":"https://lateautumn.cn/tags/node-js/"}]},{"title":"gitknow","text":"Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 想删除某段代码,又担心会出bug,那么git会记录你每次的改动,每次的迭代都会有版本,方便回退. git1.在开发过程中,经常会需要对一个文件进行修改甚至删除,但是我们又会希望保存这个文件的历史记录,达到方便回退的效果,这个时候,如果通过备份,那么管理起来就会很复杂 2.在多人开发时,每个人都会需要修改文件,那么修改或合并就会非常复杂. git是分布式的版本控制系统。分布式版本控制系统的客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份. git 环境配置如果是第一次使用,则需要配置用户名与邮箱 123456789# git config user.name 你的目标用户名# git config user.email 你的目标邮箱名# 使用--global参数，配置全局的用户名和邮箱，只需要配置一次即可。推荐配置github的用户名和密码git config --global user.name &#x27;自己的用户名&#x27;git config --global user.email &#x27;自己的正确的邮箱&#x27;# 查看配置信息git config --list git基础指令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#初始化git仓库git init#将index.html文件提交至暂存区git add index.html#将css文件下所有文件提价至暂存区git add css#将目录下所有文件提交至暂存区git add .#查看文件信息git status#将暂存区的文件提交至仓库区git commit -m &#x27;提交信息&#x27;#修改上一次提交信息git commit --amend -m#简略查看所有上传日志(不包括已回退的版本)git log --oneline#简略查看所有上传日志(包括已回退的版本)git rflog --oneline#查看工作区与暂存区代码的不同git diff#查看暂存区与仓库区代码的不同git diff --cached#查看工作区与仓库区代码的不同git diff --HEAD#查看两个版本之前代码的不同git diff xf2222 xf2223#将代码回退至指定版本号git diff --hard xf2222#创建新分区git branch 分支名称#查看分区详情git branch#删除指定分区(不能在当前分区删除当前分区)git branch -d 分区名#切换至指定分区git checkout 分区名#创建分区同时切换至此分区git checkout -b 分区名#合并其他分支至此分区git merge 分支名#上传本地文件至远程服务器git push 远程服务器地址 分支名#克隆远程服务器文件至本地git clone 远程服务器地址 本地文件夹名#从远程服务器拉取文件至本地(后续只会拉取与本地有差异的文件)git pull 远程服务器地址 git忽视文件 .gitignore 名字放在此文件夹中的文件,不会被git跟踪,也不会被上传 idea.html : 忽视idea.html文件 css : 忽视css文件夹 css/index.css : 忽视css文件夹下的index.css文件 css/*.css : 忽视css文件夹下所有css文件","path":"2021/08/16/gitknow/","date":"08-16","excerpt":"Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 想删除某段代码,又担心会出bug,那么git会记录你每次的改动,每次的迭代都会有版本,方便回退.","tags":[{"name":"git","slug":"git","permalink":"https://lateautumn.cn/tags/git/"}]},{"title":"应是飞鸿踏雪泥","text":"其实也不知道这个在这个博客上到底做些什么,也许会写一些学习历程,一些bug吧,但是我想更多的是随便写一点东西吧,也许今天写了学习历程,下一次就写了个小故事,再下一次说不定就发一些别处看到的有趣的东西上来……………………… 今天修改了图片的链接形式,hexo要想在文章内部显示图片,则需要在markdown文件下再建文件夹,实在太臃肿了,所有换成了远程图床……… 8-17","path":"2021/08/13/0811/","date":"08-13","excerpt":"其实也不知道这个在这个博客上到底做些什么,也许会写一些学习历程,一些bug吧,但是我想更多的是随便写一点东西吧,也许今天写了学习历程,下一次就写了个小故事,再下一次说不定就发一些别处看到的有趣的东西上来………………………","tags":[]},{"title":"这是我的第一个页面","text":"害,不知道改写些什么,暂时抄首诗吧,后面想到了要写什么再补上 暮晓春来迟, 先于百花知. 岁岁种桃花, 开在断肠时.","path":"2021/08/09/my-first-blog/","date":"08-09","excerpt":"害,不知道改写些什么,暂时抄首诗吧,后面想到了要写什么再补上","tags":[]},{"title":"少年剑未佩妥,便已踏入江湖","text":"此博客于2021-08-09 18:08 正式运行","path":"2021/08/09/hello-world/","date":"08-09","excerpt":"此博客于2021-08-09 18:08 正式运行","tags":[]}],"categories":[],"tags":[{"name":"总结","slug":"总结","permalink":"https://lateautumn.cn/tags/%E6%80%BB%E7%BB%93/"},{"name":"webapck","slug":"webapck","permalink":"https://lateautumn.cn/tags/webapck/"},{"name":"vue","slug":"vue","permalink":"https://lateautumn.cn/tags/vue/"},{"name":"Aplayer","slug":"Aplayer","permalink":"https://lateautumn.cn/tags/Aplayer/"},{"name":"edit","slug":"edit","permalink":"https://lateautumn.cn/tags/edit/"},{"name":"node.js","slug":"node-js","permalink":"https://lateautumn.cn/tags/node-js/"},{"name":"git","slug":"git","permalink":"https://lateautumn.cn/tags/git/"}]}